// This file was generated from JSON Schema using quicktype, do not modify it directly.
// To parse and unparse this JSON data, add this code to your project and do:
//
//    anilist, err := UnmarshalAnilist(bytes)
//    bytes, err = anilist.Marshal()

package main

import "encoding/json"

// UnmarshalAnilist parses the response coming from the API call
func UnmarshalAnilist(data []byte) (Anilist, error) {
	var r Anilist
	err := json.Unmarshal(data, &r)
	return r, err
}

// Marshal marshaling the map data into json
func (r *Anilist) Marshal() ([]byte, error) {
	return json.Marshal(r)
}

// Anilist is the main struct
type Anilist struct {
	Data Data `json:"data"`
}

// Data is the first field of the GraphQL response
type Data struct {
	Page Page `json:"Page"`
}

// Page is the page information of the response
type Page struct {
	PageInfo PageInfo `json:"pageInfo"`
	Media    []Media  `json:"media"`
}

// Media is the skeleton of the response. It holds all of the information related to the
// manga
type Media struct {
	ID          int64      `json:"id"`
	IDMal       int64      `json:"idMal"`
	CoverImage  Image      `json:"coverImage"`
	BannerImage string     `json:"bannerImage"`
	Title       Title      `json:"title"`
	StartDate   Date       `json:"startDate"`
	EndDate     Date       `json:"endDate"`
	Status      string     `json:"status"`
	Chapters    int64      `json:"chapters"`
	Volumes     int64      `json:"volumes"`
	Genres      []string   `json:"genres"`
	Tags        []Tag      `json:"tags"`
	Popularity  int64      `json:"popularity"`
	Staff       Characters `json:"staff"`
	Characters  Characters `json:"characters"`
	Relations   Relations  `json:"relations"`
}

// Characters is the abstract struct for edge information
type Characters struct {
	Edges []CharactersEdge `json:"edges"`
}

// CharactersEdge has edge information related to characters appear in manga
type CharactersEdge struct {
	ID   int64 `json:"id"`
	Role Role  `json:"role"`
	Node PNode `json:"node"`
}

// PNode Char Image and Name
type PNode struct {
	Image Image `json:"image"`
	Name  Name  `json:"name"`
}

// Image has two types: Large and Medium. Eventhough its called medium, image is rather small
type Image struct {
	Large  string `json:"large"`
	Medium string `json:"medium"`
}

// Name of the Chars. appear in the media. It also has native field.
type Name struct {
	First  string  `json:"first"`
	Last   *string `json:"last"`
	Native *string `json:"native"`
}

// Date is the type for end and start dates
type Date struct {
	Year  int64 `json:"year"`
	Month int64 `json:"month"`
	Day   int64 `json:"day"`
}

// Relations is the edge field for the relation information
type Relations struct {
	Edges []RelationsEdge `json:"edges"`
}

// RelationsEdge is the step that we have to take for fetching info from node
type RelationsEdge struct {
	ID           int64  `json:"id"`
	RelationType string `json:"relationType"`
	Node         RNode  `json:"node"`
}

// RNode is Relations information
type RNode struct {
	BannerImage string `json:"bannerImage"`
	Title       Title  `json:"title"`
	Type        string `json:"type"`
	Status      string `json:"status"`
	IDMal       int64  `json:"idMal"`
}

// Title is the title of the media
type Title struct {
	Romaji  string `json:"romaji"`
	English string `json:"english"`
	Native  string `json:"native"`
}

// Tag is custom tags in Anilist like in Steam. They're proposed by
// daily users on the site. Some of them may contains sensible(spoiler)
// information.
type Tag struct {
	Name             string `json:"name"`
	Rank             int64  `json:"rank"`
	Category         string `json:"category"`
	IsGeneralSpoiler bool   `json:"isGeneralSpoiler"`
	IsMediaSpoiler   bool   `json:"isMediaSpoiler"`
}

// PageInfo generated by the query we're sending. This information is important for
// writing cron-like servis to fetch all available(~45K) media
type PageInfo struct {
	Total       int64 `json:"total"`
	PerPage     int64 `json:"perPage"`
	CurrentPage int64 `json:"currentPage"`
	LastPage    int64 `json:"lastPage"`
	HasNextPage bool  `json:"hasNextPage"`
}

// Role type for implying which character's role. A char. can be main character of the series
// can be supporting character as well. Also, this role type applies on Authors as well.
// Author's role can be Just story,just Art or both.
// TODO: Add Story and Art distinc roles.
type Role string

// Character roles
const (
	Main       Role = "MAIN"
	StoryArt   Role = "Story & Art"
	Supporting Role = "SUPPORTING"
)
